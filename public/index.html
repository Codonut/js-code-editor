<!DOCTYPE html>
<html>
<head>
<script src="https://unpkg.com/vue"></script>
<style>

@import url('https://fonts.googleapis.com/css?family=Nunito+Sans');

body {
  margin: 100px;
}

#editor {
  font-family: 'Nunito Sans', sans-serif;
  font-size: 1.4em;
  height: 200px;
  outline: none;
}

#caret {
  display: inline-block;
  height: 1em;
  width: 2px;
  margin-right: -2px;
  background: #000;
}

#sneakyinput {
  position: absolute;
  top: -1000px;
}

.tag {
  border: 1px solid #f00;
}

</style>
</head>
<body>
<pre id="editor"><span id="caret"></span></pre>
<input id="sneakyinput" />
<script>

let caretPosition = 0;
let caret = document.getElementById('caret');
let editor = document.getElementById('editor');
let editorText = 'This is a test to see whether I like this font or not.';
let hiddenInput = document.getElementById('sneakyinput');

// We intercept key down events for keyboard commands other than typing in
// characters because the browser automatically calls onkeydown repeatedly on
// long presses (e.g. keeping backspace held for several seconds to erase
// several words).
hiddenInput.addEventListener('keydown', function(e) {
  console.log('Key down event:', e.keyCode);
  switch (e.keyCode) {
    case 8:
      // Backspace
      if (caretPosition > 0) {
        editorText = editorText.substr(0, caretPosition - 1) + editorText.substr(caretPosition);
        caretPosition--;
      }
      break;
    case 46:
      // Delete
      if (caretPosition < editorText.length) {
        editorText = editorText.substr(0, caretPosition) + editorText.substr(caretPosition + 1);
      }
      break;
    case 13:
      // Enter
      insertText('\n');
      break;
    case 37:
      // Left
      if (caretPosition > 0) {
        caretPosition--;
        updateEditorText();
      }
      break;
    case 39:
      // Right
      if (caretPosition < editorText.length) {
        caretPosition++;
        updateEditorText();
      }
      break;
    case 38:
      // Up
      break;
    case 40:
      // Down
      break;
  }
  updateEditorText();
});

// Whenever the value of the hidden input changes, it means that some characters
// have been typed and we should append them to the editor.
hiddenInput.addEventListener('input', function(e) {
  console.log('Hidden input changed:', this.value);
  insertText(this.value);
  this.value = '';
});

function insertText(text) {
  editorText = editorText.substr(0, caretPosition) + text + editorText.substr(caretPosition);
  caretPosition += text.length;
  updateEditorText();
}

function updateEditorText() {
  caret.parentNode.removeChild(caret);
  editor.innerText = '';
  let nodeBeforeCaret = document.createElement('span');
  nodeBeforeCaret.textContent = editorText.substr(0, caretPosition);
  let nodeAfterCaret = document.createElement('span');
  nodeAfterCaret.textContent = editorText.substr(caretPosition);
  editor.appendChild(nodeBeforeCaret);
  editor.appendChild(caret);
  editor.appendChild(nodeAfterCaret);
}

editor.addEventListener('click', function(e) {
  let shiftPositionBy = 0;
  for (let node = editor.firstChild; node; node = node.nextSibling) {
    if (node == caret) {
      continue;
    }
    if (node == e.target) {
      let position = findTextPosition(e.target, e);
      if (position != -1) {
        caretPosition = position + shiftPositionBy;
      }
      updateEditorText();
    } else {
      shiftPositionBy += node.textContent.length;
    }
  }
});

function findTextPosition(span, e) {
  let textNode = span.firstChild;
  // TODO: Ensure that textNode confirms to expectations (it's a text node and
  // there is no sibling).
  if (textNode.textContent.length <= 1) {
    let boundingRect = span.getBoundingClientRect();
    if (boundingRect.left <= e.pageX &&
        boundingRect.top <= e.pageY &&
        boundingRect.right >= e.pageX &&
        boundingRect.bottom >= e.pageY) {
      return 0;
    } else {
      return -1;
    }
  }
  let splitPosition = Math.floor(textNode.textContent.length / 2);
  let secondTextNode = textNode.splitText(splitPosition);
  let firstTextNode = textNode;
  let firstSpan = document.createElement('span');
  firstSpan.textContent = firstTextNode.textContent;
  let secondSpan = document.createElement('span');
  secondSpan.textContent = secondTextNode.textContent;
  span.replaceChild(firstSpan, firstTextNode);
  span.replaceChild(secondSpan, secondTextNode);
  // Now we have the following DOM structure:
  // span
  //   firstSpan
  //   secondSpan
  // TODO: Optimise this, if the span is single line and the event doesn't touch
  // then there is no need to dig inside.
  let firstPosition = findTextPosition(firstSpan, e);
  if (firstPosition != -1) {
    return firstPosition;
  }
  let secondPosition = findTextPosition(secondSpan, e);
  if (secondPosition != -1) {
    return secondPosition + splitPosition;
  }
  return -1;
}

hiddenInput.focus();
document.addEventListener('click', function(e) {
  hiddenInput.focus();
});
updateEditorText();

</script>
</body>
</html>
